
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lancet.core &mdash; The Topographica Neural Map Simulator</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/topo.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.98',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/topo.js"></script>
    <link rel="top" title="The Topographica Neural Map Simulator" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../Downloads/index.html">Downloads</a></li>
<li><a href="../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../User_Manual/index.html">User Manual</a></li>


<li><ul class="parents">



          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for lancet.core</h1><div class="highlight"><pre>
<span class="c">#</span>
<span class="c"># Lancet core</span>
<span class="c">#</span>

<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">string</span><span class="o">,</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">param</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">np_ftypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sctypes</span><span class="p">[</span><span class="s">&#39;float&#39;</span><span class="p">]</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">np</span><span class="p">,</span> <span class="n">np_ftypes</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">float_types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">+</span> <span class="n">np_ftypes</span>
<span class="k">def</span> <span class="nf">identityfn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">fp_repr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">float_types</span><span class="p">)</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="set_fp_precision"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.set_fp_precision">[docs]</a><span class="k">def</span> <span class="nf">set_fp_precision</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to set the floating precision across lancet.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BaseArgs</span><span class="o">.</span><span class="n">set_default</span><span class="p">(</span><span class="s">&#39;fp_precision&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c">#=====================#</span>
<span class="c"># Argument Specifiers #</span>
<span class="c">#=====================#</span>
</div>
<div class="viewcode-block" id="BaseArgs"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs">[docs]</a><span class="k">class</span> <span class="nc">BaseArgs</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for all argument specifiers. Argument specifiers implement</span>
<span class="sd">    Python&#39;s iterator protocol, returning arguments on each call to next(). Note</span>
<span class="sd">    that these objects should not be written as generators as they often need to</span>
<span class="sd">    be pickled.</span>

<span class="sd">    On each iteration, an argument specifier returns a list of</span>
<span class="sd">    dictionaries. Each key-value pair assigns a value to an argument and each</span>
<span class="sd">    dictionary defines a set of arguments.  The dictionaries in the list</span>
<span class="sd">    correspond to the currently available argument sets. Subsequent iterations</span>
<span class="sd">    may return further arguments for specifiers that were waiting for runtime</span>
<span class="sd">    feedback to continue (eg. hillclimbing).</span>

<span class="sd">    Such argument specifiers that require feedback are dynamic: in these cases</span>
<span class="sd">    dynamic=True and the state of the specifier must be updated between</span>
<span class="sd">    iterations via update(). Whenever possible, the schedule() method specifies</span>
<span class="sd">    the expected number of argument dictionaries on future iterations. Such</span>
<span class="sd">    expected counts may be incorrect - for example, an initial hillclimbing seed</span>
<span class="sd">    may already happen to be very close to a local optimum. Note that the</span>
<span class="sd">    update() and schedule() methods do not need to be implemented if</span>
<span class="sd">    dynamic=False.</span>

<span class="sd">    To help enforce a declarative style, public parameters are declared constant</span>
<span class="sd">    and cannot be mutated after initialisation. Argument specifiers need to be</span>
<span class="sd">    declared correctly where they are used.</span>

<span class="sd">    The varying_keys and constant_keys methods makes the distinction between</span>
<span class="sd">    arguments that are manipulated between runs and the ones that stay constant.</span>
<span class="sd">    The values of the arguments that vary is often of more interest than the</span>
<span class="sd">    values of the arguments held constant and varying arguments are sorted by</span>
<span class="sd">    how fast they vary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            Flag to indicate whether the argument specifier needs to have its</span>
<span class="s">            state updated via the update() method between iterations. In other</span>
<span class="s">            words, if the arguments cannot be known ahead of time (eg. parameter</span>
<span class="s">            search), dynamic must be set to True.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">fp_precision</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The floating point precision to use for floating point values.  Unlike</span>
<span class="s">         other basic Python types, floats need care with their representation as</span>
<span class="s">         you only want to display up to the precision actually specified.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseArgs</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_args</span> <span class="o">=</span> <span class="p">([],[],</span><span class="bp">None</span><span class="p">,{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([],[</span><span class="s">&#39;fp_precision&#39;</span><span class="p">,</span> <span class="s">&#39;dynamic&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">())</span>

<div class="viewcode-block" id="BaseArgs.spec_formatter"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.spec_formatter">[docs]</a>    <span class="k">def</span> <span class="nf">spec_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="s">&quot; Formats the elements of an argument set appropriately&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="BaseArgs.constant_keys"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.constant_keys">[docs]</a>    <span class="k">def</span> <span class="nf">constant_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of parameter names whose values are constant as the</span>
<span class="sd">        argument specifier is iterated.  Note that the union of constant and</span>
<span class="sd">        varying_keys should partition the entire set of keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="BaseArgs.constant_items"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.constant_items">[docs]</a>    <span class="k">def</span> <span class="nf">constant_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the set of constant items as a list of tuples. This allows easy</span>
<span class="sd">        conversion to dictionary format. Note, the items should be supplied in</span>
<span class="sd">        the same key ordering as for constant_keys() for consistency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="BaseArgs.varying_keys"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.varying_keys">[docs]</a>    <span class="k">def</span> <span class="nf">varying_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of parameters whose values vary as the argument</span>
<span class="sd">        specifier is iterated.  Whenever it is possible, keys should be sorted</span>
<span class="sd">        from those slowest to faster varying and sorted alphanumerically within</span>
<span class="sd">        groups that vary at the same rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
    <span class="k">def</span> <span class="nf">round_floats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="p">):</span>
        <span class="n">_round</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np_ftypes</span><span class="p">)</span> <span class="k">else</span> <span class="nb">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">_round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fp_precision</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">float_types</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="p">)</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">)</span>

<div class="viewcode-block" id="BaseArgs.next"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.next">[docs]</a>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to get a list of specifications: dictionaries with parameter name</span>
<span class="sd">        keys and string values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>
</div>
<div class="viewcode-block" id="BaseArgs.update"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to update the state of the iterator when dynamic= True.</span>
<span class="sd">        Typically this methods is receiving metric values generated by the</span>
<span class="sd">        previous set of tasks in order to determine the next desired point in</span>
<span class="sd">        the parameter space. If the update fails or data is None, StopIteration</span>
<span class="sd">        should be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="BaseArgs.schedule"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.schedule">[docs]</a>    <span class="k">def</span> <span class="nf">schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specifies the expected number of specifications that will be returned on</span>
<span class="sd">        future iterations if dynamic=True. This is simply a list of integers</span>
<span class="sd">        specifying the number of argument sets to be returned on each subsequent</span>
<span class="sd">        call to next(). Return None if scheduling information cnanot be</span>
<span class="sd">        estimated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="BaseArgs.copy"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to avoid using the specifier without exhausting it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_collect_by_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">specs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary like object with the lists of values collapsed by</span>
<span class="sd">        their respective key. Useful to find varying vs constant keys and to</span>
<span class="sd">        find how fast keys vary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Collects key, value tuples as list of lists then flatten using chain</span>
        <span class="n">allkeys</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([[(</span><span class="n">k</span><span class="p">,</span> <span class="n">run</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">run</span><span class="p">]</span> <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">])</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">allkeys</span><span class="p">:</span> <span class="n">collection</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span>

<div class="viewcode-block" id="BaseArgs.show"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to inspect the available argument values in</span>
<span class="sd">        human-readable format. When dynamic, not all argument values may be</span>
<span class="sd">        available.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">enumerated</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">copied</span><span class="p">)]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">group_ind</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enumerated</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enumerated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;Group </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">group_ind</span><span class="p">)</span>
            <span class="n">ordering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()</span>
            <span class="c"># Ordered nicely by varying_keys definition.</span>
            <span class="n">spec_lines</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordering</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spec_lines</span><span class="p">)]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Remaining arguments not available for </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenates two argument specifiers. See StaticConcatenate and</span>
<span class="sd">        DynamicConcatenate documentation respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dynamic</span><span class="p">),</span> <span class="s">&#39;Cannot concatenate two dynamic specifiers.&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="k">return</span> <span class="n">DynamicConcatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>                             <span class="k">return</span> <span class="n">StaticConcatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the cartesian product of two argument specifiers. See</span>
<span class="sd">        StaticCartesianProduct and DynamicCartesianProduct documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">dynamic</span><span class="p">),</span> \
            <span class="s">&#39;Cannot take Cartesian product two dynamic specifiers.&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="k">return</span> <span class="n">DynamicCartesianProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>                             <span class="k">return</span> <span class="n">StaticCartesianProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_cartesian_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_specs</span><span class="p">,</span> <span class="n">second_specs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the Cartesian product of the specifications. Result will contain N</span>
<span class="sd">        specifications where N = len(first_specs) * len(second_specs) and keys</span>
<span class="sd">        are merged.  Example: [{&#39;a&#39;:1},{&#39;b&#39;:2}] * [{&#39;c&#39;:3},{&#39;d&#39;:4}] =</span>
<span class="sd">        [{&#39;a&#39;:1,&#39;c&#39;:3},{&#39;a&#39;:1,&#39;d&#39;:4},{&#39;b&#39;:2,&#39;c&#39;:3},{&#39;b&#39;:2,&#39;d&#39;:4}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>  <span class="p">[</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                          <span class="nb">list</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                          <span class="nb">list</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                      <span class="p">))</span>
                 <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">first_specs</span> <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">second_specs</span> <span class="p">]</span>

<div class="viewcode-block" id="BaseArgs.pprint_args"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.BaseArgs.pprint_args">[docs]</a>    <span class="k">def</span> <span class="nf">pprint_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos_args</span><span class="p">,</span> <span class="n">keyword_args</span><span class="p">,</span> <span class="n">infix_operator</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to define the positional arguments and keyword order for pretty printing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infix_operator</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_args</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">keyword_args</span><span class="o">==</span><span class="p">[]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Infix format requires exactly two positional arguments and no keywords&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">kwargs</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyword_args</span> <span class="o">+</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">pos_args</span><span class="p">,</span> <span class="n">infix_operator</span><span class="p">,</span> <span class="n">extra_params</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cycle</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tab</span> <span class="o">=</span> <span class="s">&#39;   &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty printer that prints only the modified keywords and generates flat</span>
<span class="sd">        representations (for repr) and optionally annotates with a comment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">pos_args</span><span class="p">,</span> <span class="n">infix_operator</span><span class="p">,</span> <span class="n">extra_params</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_args</span>
        <span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">indent</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">flat</span> <span class="k">else</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">flat</span> <span class="k">else</span> <span class="n">tab</span> <span class="o">*</span> <span class="n">level</span><span class="p">)</span>
        <span class="n">prettify</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BaseArgs</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">flat</span>
        <span class="n">pretty</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">_pprint</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">prettify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="n">modified</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">(</span><span class="n">onlychanged</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
        <span class="n">pkwargs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">modified</span><span class="p">)]</span> <span class="o">+</span> <span class="n">extra_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos_args</span><span class="p">]</span> <span class="o">+</span> <span class="n">pkwargs</span>

        <span class="n">len_ckeys</span><span class="p">,</span> <span class="n">len_vkeys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">())</span>
        <span class="n">info_triple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                       <span class="s">&#39;, </span><span class="si">%d</span><span class="s"> constant key(s)&#39;</span> <span class="o">%</span> <span class="n">len_ckeys</span> <span class="k">if</span> <span class="n">len_ckeys</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">,</span>
                       <span class="s">&#39;, </span><span class="si">%d</span><span class="s"> varying key(s)&#39;</span>  <span class="o">%</span> <span class="n">len_vkeys</span> <span class="k">if</span> <span class="n">len_vkeys</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="s">&#39;# == </span><span class="si">%d</span><span class="s"> items</span><span class="si">%s%s</span><span class="s"> ==</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">info_triple</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotation</span><span class="p">]</span> <span class="k">if</span> <span class="n">annotate</span> <span class="k">else</span> <span class="p">[]</span>    <span class="c"># Optional annotating comment</span>

        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">(...)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">infix_operator</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">triple</span> <span class="o">=</span> <span class="p">(</span><span class="n">pretty</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">pos_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">infix_operator</span><span class="p">,</span> <span class="n">pretty</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">pos_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">triple</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">(&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">arg_list</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>  <span class="p">(</span><span class="n">br</span><span class="o">+</span><span class="n">indent</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">pretty</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span><span class="p">[</span><span class="n">br</span><span class="o">+</span><span class="p">(</span><span class="n">tab</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="s">&#39;)&#39;</span><span class="p">]</span> <span class="c"># Remove trailing comma</span>

        <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="StaticArgs"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.StaticArgs">[docs]</a><span class="k">class</span> <span class="nc">StaticArgs</span><span class="p">(</span><span class="n">BaseArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for many important static argument specifiers (dynamic=False)</span>
<span class="sd">    though also useful in its own right. Can be constructed from launcher log</span>
<span class="sd">    files and gives full control over the output arguments.Accepts the full</span>
<span class="sd">    static specification as a list of dictionaries, provides all necessary</span>
<span class="sd">    mechanisms for identifying varying and constant keys, implements next()</span>
<span class="sd">    appropriately, does not exhaust like dynamic specifiers and has useful</span>
<span class="sd">    support for len().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">specs</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">          The static list of specifications (ie. dictionaries) to be</span>
<span class="s">          returned by the specifier. Float values are rounded to</span>
<span class="s">          fp_precision.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fp_precision</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">fp_precision</span> <span class="o">=</span> <span class="n">BaseArgs</span><span class="o">.</span><span class="n">fp_precision</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">round_floats</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">dynamic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="n">fp_precision</span><span class="p">,</span> <span class="n">specs</span><span class="o">=</span><span class="n">specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;specs&#39;</span><span class="p">],[])</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span><span class="o">=</span><span class="bp">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span>

    <span class="k">def</span> <span class="nf">_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">idfun</span><span class="o">=</span><span class="nb">repr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note: repr() must be implemented properly on all objects. This is</span>
<span class="sd">        assumed by lancet when Python objects need to be formatted to string</span>
<span class="sd">        representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">seen</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">idfun</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sequence</span>
                <span class="k">if</span> <span class="n">idfun</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">constant_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_by_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique</span><span class="p">(</span><span class="n">collection</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">constant_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_by_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">collection</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">varying_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_by_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="n">constant_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">())</span>
        <span class="n">unordered_varying</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">constant_set</span><span class="p">)</span>
        <span class="c"># Finding out how fast keys are varying</span>
        <span class="n">grouplens</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">len</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">collection</span><span class="p">[</span><span class="n">k</span><span class="p">])]),</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">collection</span><span class="p">]</span>
        <span class="n">varying_counts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grouplens</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">unordered_varying</span><span class="p">)]</span>
        <span class="c"># Grouping keys with common frequency alphanumerically (desired behaviour).</span>
        <span class="n">ddict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">varying_counts</span><span class="p">:</span> <span class="n">ddict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">alphagroups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ddict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ddict</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">alphagroups</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="StaticConcatenate"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.StaticConcatenate">[docs]</a><span class="k">class</span> <span class="nc">StaticConcatenate</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    StaticConcatenate is the sequential composition of two StaticArg</span>
<span class="sd">    specifiers. The specifier created by the compositon (firsts + second)</span>
<span class="sd">    generates the arguments in first followed by the arguments in</span>
<span class="sd">    second.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">first</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            The first static specifier used to generate the concatenation.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">second</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            The second static specifier used to generate the concatenation.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>

        <span class="n">max_precision</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">,</span> <span class="n">second</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">)</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">specs</span> <span class="o">+</span> <span class="n">second</span><span class="o">.</span><span class="n">specs</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StaticConcatenate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="n">max_precision</span><span class="p">,</span>
                                                <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="s">&#39;second&#39;</span><span class="p">],[],</span> <span class="n">infix_operator</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="StaticCartesianProduct"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.StaticCartesianProduct">[docs]</a><span class="k">class</span> <span class="nc">StaticCartesianProduct</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    StaticCartesianProduct is the cartesian product of two StaticArg</span>
<span class="sd">    specifiers. The specifier created by the compositon (firsts * second)</span>
<span class="sd">    generates the cartesian produce of the arguments in first followed by the</span>
<span class="sd">    arguments in second. Note that len(first * second) = len(first)*len(second)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">first</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            The first static specifier used to generate the Cartesian product.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">second</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            The second static specifier used to generate the Cartesian product.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>

        <span class="n">max_precision</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">,</span> <span class="n">second</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">)</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_product</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">specs</span><span class="p">,</span> <span class="n">second</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>

        <span class="n">overlap</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()</span> <span class="o">+</span> <span class="n">first</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">())</span>
                   <span class="o">&amp;</span>  <span class="nb">set</span><span class="p">(</span><span class="n">second</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()</span> <span class="o">+</span> <span class="n">second</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="n">overlap</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(),</span> <span class="s">&#39;Sets of keys cannot overlap between argument specifiers in cartesian product.&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StaticCartesianProduct</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="n">max_precision</span><span class="p">,</span>
                                                     <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="s">&#39;second&#39;</span><span class="p">],[],</span> <span class="n">infix_operator</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Args"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.Args">[docs]</a><span class="k">class</span> <span class="nc">Args</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Allows easy instantiation of a single set of arguments using keywords.</span>
<span class="sd">    Useful for instantiating constant arguments before applying a cartesian</span>
<span class="sd">    product.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">kwargs</span> <span class="o">!=</span> <span class="p">{},</span> <span class="s">&quot;Empty specification not allowed.&quot;</span>
        <span class="n">fp_precision</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;fp_precision&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="s">&#39;fp_precision&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Args</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="n">fp_precision</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([],</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="LinearArgs"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.LinearArgs">[docs]</a><span class="k">class</span> <span class="nc">LinearArgs</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LinearArgs generates an argument from a numerically interpolated range which</span>
<span class="sd">    is linear by default. An optional function can be specified to sample a</span>
<span class="sd">    numeric range with regular intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">key</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The key assigned to values computed over the linear numeric range.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">start_value</span> <span class="o">=</span>  <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The starting numeric value of the linear interpolation.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">end_value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The ending numeric value of the linear interpolation (inclusive).&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">steps</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The number of steps to interpolate over. Default is 2 which returns the</span>
<span class="s">         start and end values without interpolation.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="c"># Can&#39;t this be a lambda?</span>
    <span class="n">mapfn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Callable</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">identityfn</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The function to be mapped across the linear range. Identity  by default &#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">start_value</span><span class="p">,</span> <span class="n">end_value</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mapfn</span><span class="o">=</span><span class="n">identityfn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_value</span><span class="p">,</span> <span class="n">end_value</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[{</span><span class="n">key</span><span class="p">:</span><span class="n">mapfn</span><span class="p">(</span><span class="n">val</span><span class="p">)}</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span> <span class="p">]</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">LinearArgs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">start_value</span><span class="o">=</span><span class="n">start_value</span><span class="p">,</span>
                                         <span class="n">end_value</span><span class="o">=</span><span class="n">end_value</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
                                         <span class="n">mapfn</span><span class="o">=</span><span class="n">mapfn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;key&#39;</span><span class="p">,</span> <span class="s">&#39;start_value&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;end_value&#39;</span><span class="p">,</span> <span class="s">&#39;steps&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="LinearArgs.linspace"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.LinearArgs.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Nice simple replacement for numpy linspace&quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">nm1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nm1inv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">nm1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nm1inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">start</span><span class="o">*</span><span class="p">(</span><span class="n">nm1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">stop</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span>
</div></div>
<div class="viewcode-block" id="ListArgs"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.ListArgs">[docs]</a><span class="k">class</span> <span class="nc">ListArgs</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An argument specifier that takes its values from a given list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">list_values</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The list values that are to be returned by the specifier&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">list_key</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">         The key assigned to the elements of the given list.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_key</span><span class="p">,</span> <span class="n">list_values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">assert</span> <span class="n">list_values</span> <span class="o">!=</span> <span class="p">[],</span> <span class="s">&quot;Empty list not allowed.&quot;</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[{</span><span class="n">list_key</span><span class="p">:</span><span class="n">val</span><span class="p">}</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">list_values</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ListArgs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">list_key</span><span class="o">=</span><span class="n">list_key</span><span class="p">,</span> <span class="n">list_values</span><span class="o">=</span><span class="n">list_values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;list_key&#39;</span><span class="p">,</span> <span class="s">&#39;list_values&#39;</span><span class="p">],</span> <span class="p">[])</span>
</div>
<div class="viewcode-block" id="Log"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.Log">[docs]</a><span class="k">class</span> <span class="nc">Log</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specifier that loads arguments from a log file in tid (task id) order.  For</span>
<span class="sd">    full control over the arguments, you can use this class with StaticArgs as</span>
<span class="sd">    follows: StaticArgs(Log.extract_log(&lt;log_file&gt;).values()),</span>

<span class="sd">    This wrapper class allows a concise representation of log specifiers with</span>
<span class="sd">    the option of adding the task id to the loaded specifications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log_path</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">              The relative or absolute path to the log file. If a relative path</span>
<span class="s">              is given, the absolute path is computed with param.normalize_path</span>
<span class="s">              (os.getcwd() by default).&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">tid_key</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">&#39;tid&#39;</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">               If not None, the key given to the tid values included in the</span>
<span class="s">               loaded specifications. If None, the tid number is ignored.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Log.extract_log"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.Log.extract_log">[docs]</a>    <span class="k">def</span> <span class="nf">extract_log</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="n">dict_type</span><span class="o">=</span><span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the log file generated by a launcher and returns dictionary with</span>
<span class="sd">        tid keys and specification values.</span>

<span class="sd">        Ordering can be maintained by setting dict_type to the appropriate</span>
<span class="sd">        constructor. Keys are converted from unicode to strings for kwarg use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">normalize_path</span><span class="p">(</span><span class="n">log_path</span><span class="p">),</span><span class="s">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">log</span><span class="p">)</span>
            <span class="n">uzipped</span> <span class="o">=</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span> <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">)</span>
            <span class="n">szipped</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">uzipped</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dict_type</span><span class="p">(</span><span class="n">szipped</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Log.write_log"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.Log.write_log">[docs]</a>    <span class="k">def</span> <span class="nf">write_log</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">allow_append</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the supplied specifications to the log path. The data may be</span>
<span class="sd">        supplied as either as a StaticSpecifier or as a list of dictionaries.</span>

<span class="sd">        By default, specifications will be appropriately appended to an existing</span>
<span class="sd">        log file. This can be disabled by setting allow_append to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">log_path</span><span class="p">)</span>
        <span class="n">listing</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_append</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Appending has been disabled and file </span><span class="si">%s</span><span class="s"> exists&#39;</span> <span class="o">%</span> <span class="n">log_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">listing</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">StaticArgs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Can only write static specifiers or dictionary lists to log file.&#39;</span><span class="p">)</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">listing</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">specs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;List elements must be dictionaries.&#39;</span><span class="p">)</span>

        <span class="n">log_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s">&#39;r+&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_path</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">log_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">ascending_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="n">log_str</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">el</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ascending_indices</span><span class="p">,</span> <span class="n">specs</span><span class="p">)])</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="n">log_str</span> <span class="k">if</span> <span class="n">append</span> <span class="k">else</span> <span class="n">log_str</span><span class="p">)</span>
        <span class="n">log_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_path</span><span class="p">,</span> <span class="n">tid_key</span><span class="o">=</span><span class="s">&#39;tid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">log_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Log</span><span class="o">.</span><span class="n">extract_log</span><span class="p">(</span><span class="n">log_path</span><span class="p">)</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">tid_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">log_specs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">+</span><span class="p">[(</span><span class="n">tid_key</span><span class="p">,</span><span class="n">idx</span><span class="p">)])</span> <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">log_items</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">log_items</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Log</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">log_specs</span><span class="p">,</span> <span class="n">log_path</span><span class="o">=</span><span class="n">log_path</span><span class="p">,</span> <span class="n">tid_key</span><span class="o">=</span><span class="n">tid_key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;log_path&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;tid_key&#39;</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Indexed"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.Indexed">[docs]</a><span class="k">class</span> <span class="nc">Indexed</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two StaticArgs, link the arguments of via an index value.</span>
<span class="sd">    The index value of the given key must have a matching entry in the</span>
<span class="sd">    index. Once a match is found, the results are merged with the</span>
<span class="sd">    resulting ordering identical to that of the input operand.</span>

<span class="sd">    The value used for matching is specified by the key</span>
<span class="sd">    name. Uniqueness of keys in the index is enforced and these keys</span>
<span class="sd">    must be a superset of those expressed by the operand.</span>

<span class="sd">    By default, fp_precision is the maximum of that used by the</span>
<span class="sd">    operand and index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">              The source specifier from which the index_key is extracted for</span>
<span class="s">              looking up the corresponding value in the index.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">             The specifier in which a lookup is performed to find the unique</span>
<span class="s">             matching specification. The index must be longer than the operand</span>
<span class="s">             and the values of the index_key must be unique.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">index_key</span>  <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">             The common key in both the index and the operand used to</span>
<span class="s">             index the former specifications into the latter.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index_key</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">StaticArgs</span><span class="p">),</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">StaticArgs</span><span class="p">)]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Can only index two Static Argument specifiers&#39;</span><span class="p">)</span>

        <span class="n">max_precision</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">fp_precision</span><span class="p">)</span>
        <span class="n">fp_precision</span> <span class="o">=</span>  <span class="n">max_precision</span> <span class="k">if</span> <span class="n">fp_precision</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">fp_precision</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">specs</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">specs</span><span class="p">,</span> <span class="n">index_key</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Indexed</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">fp_precision</span><span class="o">=</span><span class="n">fp_precision</span><span class="p">,</span> <span class="n">index_key</span><span class="o">=</span><span class="n">index_key</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="n">operand</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;operand&#39;</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">,</span> <span class="s">&#39;index_key&#39;</span><span class="p">],[])</span>

    <span class="k">def</span> <span class="nf">_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">index_specs</span><span class="p">,</span> <span class="n">index_key</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="p">[</span><span class="n">index_key</span><span class="p">]</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">]</span>
        <span class="n">index_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">spec</span><span class="p">[</span><span class="n">index_key</span><span class="p">]</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">index_specs</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">index_keys</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Keys in index must all be unique&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">index_keys</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Keys in specifier must be subset of keys in index.&quot;</span><span class="p">)</span>

        <span class="n">spec_items</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
        <span class="n">index_idxmap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">index_keys</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_keys</span><span class="p">))))</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">**</span><span class="n">index_specs</span><span class="p">[</span><span class="n">index_idxmap</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">spec_items</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="FilePattern"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.FilePattern">[docs]</a><span class="k">class</span> <span class="nc">FilePattern</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A FilePattern specifier allows files to be located via an extended form of</span>
<span class="sd">    globbing. For example, you can find the absolute filenames of all npz files</span>
<span class="sd">    in the data subdirectory (relative to the root) that start with the filename</span>
<span class="sd">    &#39;timeseries&#39; use the pattern &#39;data/timeseries*.npz&#39;.</span>

<span class="sd">    In addition to globbing supported by the glob module, patterns can extract</span>
<span class="sd">    metadata from filenames using a subset of the Python format specification</span>
<span class="sd">    syntax. To illustrate, you can use &#39;data/timeseries-{date}.npz&#39; to record</span>
<span class="sd">    the date strings associated with matched files. Note that a particular named</span>
<span class="sd">    fields can only be used in a particular pattern once.</span>

<span class="sd">    By default metadata is extracted as strings but format types are supported</span>
<span class="sd">    in the usual manner eg. &#39;data/timeseries-{day:d}-{month:d}.npz&#39; will extract</span>
<span class="sd">    the day and month from the filename as integers. Only field names and types</span>
<span class="sd">    are recognised with all other format specification ignored. Type codes</span>
<span class="sd">    supported: &#39;d&#39;, &#39;b&#39;, &#39;o&#39;, &#39;x&#39;, &#39;e&#39;,&#39;E&#39;,&#39;f&#39;, &#39;F&#39;,&#39;g&#39;, &#39;G&#39;, &#39;n&#39; (otherwise</span>
<span class="sd">    result is a string).</span>

<span class="sd">    Note that ordering is determined via ascending alphanumeric sort and that</span>
<span class="sd">    actual filenames should not include any globbing characters, namely: &#39;?&#39;,&#39;*&#39;,&#39;[&#39;</span>
<span class="sd">    and &#39;]&#39; (general good practice for filenames).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">key</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">             The key name given to the matched file path strings.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">pattern</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
              <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;The pattern files are to be searched against.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">             The root directory from which patterns are to be loaded.  If set to</span>
<span class="s">             None, normalize_path.prefix is used (os.getcwd() by default).&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="FilePattern.directory"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.FilePattern.directory">[docs]</a>    <span class="k">def</span> <span class="nf">directory</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">directory</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load all the files in a given directory. Only files with the given file</span>
<span class="sd">        extension are loaded if the extension is specified. The given kwargs are</span>
<span class="sd">        passed through to the normal constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">normalize_path</span><span class="o">.</span><span class="n">prefix</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">root</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">extension</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="n">extension</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">directory</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="s">&#39;*&#39;</span> <span class="o">+</span> <span class="n">suffix</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">directory</span><span class="p">,</span><span class="s">&#39;*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">format_parse</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">Formatter</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">el</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">format_parse</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Directory cannot contain format field specifications&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">normalize_path</span><span class="o">.</span><span class="n">prefix</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">root</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_expansion</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">updated_specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_file_metadata</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilePattern</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">updated_specs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">,</span>
                                          <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">updated_specs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%r</span><span class="s">: No matches found.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;key&#39;</span><span class="p">,</span> <span class="s">&#39;pattern&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;root&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="FilePattern.fields"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.FilePattern.fields">[docs]</a>    <span class="k">def</span> <span class="nf">fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the fields specified in the pattern using Python&#39;s formatting</span>
<span class="sd">        mini-language.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parse</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">Formatter</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">parse</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">_load_file_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hook to allow a subclass to load metadata from the located files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">specs</span>

    <span class="k">def</span> <span class="nf">_load_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span><span class="c">#, lexsort):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the files that match the given pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">expanded_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_pattern</span><span class="p">(</span><span class="n">path_pattern</span><span class="p">)</span>

        <span class="n">specs</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tags</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expanded_paths</span><span class="p">:</span>
            <span class="n">rootdir</span> <span class="o">=</span> <span class="n">path</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">filepath</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span><span class="o">**</span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">filepath</span><span class="p">}))</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_expand_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From the pattern decomposition, finds the absolute paths matching the pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">globpattern</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decompose_pattern</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="n">filelist</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">globpattern</span><span class="p">)</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fields</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">expansion</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fname</span><span class="p">,</span> <span class="p">{}))</span>
                <span class="k">continue</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">match_items</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">match_items</span><span class="p">)</span>
            <span class="n">expansion</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fname</span><span class="p">,</span> <span class="n">tags</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">expansion</span>

    <span class="k">def</span> <span class="nf">_decompose_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path pattern with format declaration, generates a four-tuple</span>
<span class="sd">        (glob_pattern, regexp pattern, fields, type map)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;~lancet~sep~&#39;</span>
        <span class="n">float_codes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;G&#39;</span><span class="p">,</span> <span class="s">&#39;n&#39;</span><span class="p">]</span>
        <span class="n">typecodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">float_codes</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="nb">bin</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;o&#39;</span><span class="p">,</span><span class="nb">oct</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="nb">hex</span><span class="p">)])</span>
        <span class="n">parse</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">Formatter</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
        <span class="n">text</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">parse</span><span class="p">)</span>

        <span class="c"># Finding the field types from format string</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="n">constructor</span> <span class="o">=</span>  <span class="n">typecodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">code</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">constructor</span><span class="p">:</span> <span class="n">types</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">field</span><span class="p">,</span> <span class="n">constructor</span><span class="p">)]</span>

        <span class="n">stars</span> <span class="o">=</span>  <span class="p">[</span><span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span> <span class="k">else</span> <span class="s">&#39;*&#39;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>
        <span class="n">globpattern</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="o">+</span><span class="n">star</span> <span class="k">for</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="n">star</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">stars</span><span class="p">))</span>

        <span class="n">refields</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span> <span class="k">else</span> <span class="n">sep</span><span class="o">+</span><span class="p">(</span><span class="s">&#39;(?P&lt;</span><span class="si">%s</span><span class="s">&gt;.*?)&#39;</span><span class="o">%</span> <span class="n">f</span><span class="p">)</span><span class="o">+</span><span class="n">sep</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">]</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">text</span><span class="o">+</span><span class="n">group</span> <span class="k">for</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="n">group</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">refields</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">globpattern</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\\</span><span class="s">*&#39;</span><span class="p">,</span><span class="s">&#39;.*&#39;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LexSorted"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.LexSorted">[docs]</a><span class="k">class</span> <span class="nc">LexSorted</span><span class="p">(</span><span class="n">StaticArgs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Argument specifiers normally have a clearly defined but implicit, default</span>
<span class="sd">    orderings. Sometimes a different ordering is desired, typically for</span>
<span class="sd">    inspecting the structure of the specifier in some way</span>
<span class="sd">    (ie. viewing). Applying LexSorted to a specifier allows the desired</span>
<span class="sd">    ordering to be achieved.</span>

<span class="sd">    The lexical sort order is specified in the &#39;order&#39; parameter which takes a</span>
<span class="sd">    list of strings. Each string is a key name prefixed by &#39;+&#39; or &#39;-&#39; for</span>
<span class="sd">    ascending and descending sort respectively. If the key is not found in the</span>
<span class="sd">    operand&#39;s set of varying keys, it is ignored.</span>

<span class="sd">    To illustrate, if order=[&#39;+id&#39;, &#39;-time&#39;] then the specifier would be sorted</span>
<span class="sd">    by ascending by &#39;id&#39;value but where id values are equal, it would be sorted</span>
<span class="sd">    by descending &#39;time&#39; value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">operand</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">              The source specifier which is to be lexically sorted.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">             An ordered list of annotated keys for lexical sorting. An annotated</span>
<span class="s">             key is the usual key name prefixed with either &#39;+&#39; (for ascending</span>
<span class="s">             sort) or &#39;-&#39; (for descending sort). By default, no sorting is applied.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexsort</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LexSorted</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="n">operand</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;operand&#39;</span><span class="p">,</span><span class="s">&#39;order&#39;</span><span class="p">],[])</span>

    <span class="k">def</span> <span class="nf">_lexsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A lexsort is specified using normal key string prefixed by &#39;+&#39; (for</span>
<span class="sd">        ascending) or &#39;-&#39; for (for descending).</span>

<span class="sd">        Note that in Python 2, if a key is missing, None is returned (smallest</span>
<span class="sd">        Python value). In Python 3, an Exception will be raised regarding</span>
<span class="sd">        comparison of heterogenous types.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">specs</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">order</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Please prefix sort keys with either &#39;+&#39; (for ascending) or &#39;-&#39; for descending&quot;</span><span class="p">)</span>

        <span class="n">sort_cycles</span> <span class="o">=</span> <span class="p">[(</span><span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;+&#39;</span> <span class="k">else</span> <span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">operand</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()]</span>


        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ascending</span><span class="p">)</span> <span class="ow">in</span> <span class="n">sort_cycles</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">ascending</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">specs</span>


<span class="c">#=============================#</span>
<span class="c"># Dynamic argument specifiers #</span>
<span class="c">#=============================#</span>
</div>
<span class="k">class</span> <span class="nc">DynamicConcatenate</span><span class="p">(</span><span class="n">BaseArgs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Concatenate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">dynamic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_sent</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">second</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">second</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="s">&#39;second&#39;</span><span class="p">],[],</span> <span class="n">infix_operator</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">first_schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">schedule</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">first_schedule</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">first_schedule</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">second_schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">schedule</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">second_schedule</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span><span class="p">)]</span><span class="o">+</span> <span class="n">second_schedule</span>

    <span class="k">def</span> <span class="nf">constant_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">varying_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">dynamic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_sent</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_sent</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_first_sent</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>  <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DynamicCartesianProduct</span><span class="p">(</span><span class="n">BaseArgs</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>

        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">())</span> <span class="o">&amp;</span>  <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">overlap</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(),</span> <span class="s">&#39;Sets of keys cannot overlap between argument specifiers in cartesian product.&#39;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianProduct</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">dynamic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">first</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">second</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">second</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pprint_args</span><span class="p">([</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="s">&#39;second&#39;</span><span class="p">],[],</span> <span class="n">infix_operator</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constant_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">varying_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">first_schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">schedule</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">first_schedule</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">first_schedule</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">second_schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">schedule</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">second_schedule</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">second_schedule</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">first_spec</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_product</span><span class="p">(</span><span class="n">first_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_cached</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">second_spec</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_cached</span><span class="p">,</span> <span class="n">second_spec</span><span class="p">)</span>

<div class="viewcode-block" id="applying"><a class="viewcode-back" href="../../Reference_Manual/lancet.core-module.html#lancet.core.applying">[docs]</a><span class="k">class</span> <span class="nc">applying</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to invoke Python code (callables) with a specifier, optionally</span>
<span class="sd">    creating a log of the arguments used.  By default data is passed in as</span>
<span class="sd">    keywords but positional arguments can be specified using the &#39;args&#39;</span>
<span class="sd">    parameter.</span>

<span class="sd">    Automatically accumulates the return values of any callable (functions or</span>
<span class="sd">    classes). The return value is an instance of this class which may be called</span>
<span class="sd">    without arguments to repeat the last operation or bound to another function</span>
<span class="sd">    with the same call signature to call that instead.</span>

<span class="sd">    values = applying(ListArgs(&#39;value&#39;,[1,2,3]))</span>

<span class="sd">    values(lambda value: value +1)</span>
<span class="sd">    values(lambda value: value**2)</span>
<span class="sd">    values() # Repeats the last function set</span>

<span class="sd">    values.accumulator</span>
<span class="sd">    ... [2, 3, 4, 1, 4, 9, 1, 4, 9]</span>

<span class="sd">    May also be used as a decorator to wrap a single function:</span>

<span class="sd">    @applying(ListArgs(&#39;value&#39;,[1,2,3,4]))</span>
<span class="sd">    def add_one(value=None):</span>
<span class="sd">        return value +1</span>

<span class="sd">    add_one.accumulator</span>
<span class="sd">    ... [2, 3, 4]</span>

<span class="sd">    Dynamic specifiers may be updated as necessary with the update_fn parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">specifier</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">StaticArgs</span><span class="p">,</span>
               <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;The specifier from which the positional and keyword</span>
<span class="s">                arguments are to be derived.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;The list of positional arguments to generate.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">callee</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Callable</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;The function that is to be applied.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">log_path</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">              Optional path to a log file for recording the list of arguments used.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">update_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Callable</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="k">lambda</span> <span class="n">spec</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">                 Hook to call to update dynamic specifiers as necessary.  This</span>
<span class="s">                 callable takes two arguments, first the specifier that needs</span>
<span class="s">                 updating and the list of accumulated values from the current</span>
<span class="s">                 group of results.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="n">accumulator</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span> <span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Accumulates the return values of the callable.&#39;&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specifier</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">applying</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">specifier</span><span class="o">=</span><span class="n">specifier</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">all_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="o">.</span><span class="n">constant_keys</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="o">.</span><span class="n">varying_keys</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_keys</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_args_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separates out args from kwargs given a list of non-kwarg arguments.</span>
<span class="sd">        When the args list is empty, kwargs alone are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span> <span class="o">==</span><span class="p">[]:</span> <span class="k">return</span> <span class="n">specs</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">specs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">kwarg_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">specs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">arg_list</span><span class="p">,</span> <span class="n">kwarg_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callee</span> <span class="o">=</span> <span class="n">fn</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;No callable specified.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Log </span><span class="si">%r</span><span class="s"> already exists.&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">)</span>

        <span class="n">log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">concurrent_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="p">:</span>
            <span class="n">concurrent_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">specs</span> <span class="ow">in</span> <span class="n">concurrent_group</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callee</span><span class="p">(</span><span class="o">**</span><span class="n">specs</span><span class="p">)</span>
                <span class="n">concurrent_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="p">,</span> <span class="n">concurrent_values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accumulator</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">concurrent_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">:</span>
            <span class="n">Log</span><span class="o">.</span><span class="n">write_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">allow_append</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="p">,</span>
                <span class="s">&#39;args=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                <span class="s">&#39;accumulator=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulator</span><span class="p">]</span>
        <span class="n">arg_str</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">arg_list</span> <span class="k">if</span> <span class="n">el</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39;applying(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">arg_str</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;args=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
                    <span class="s">&#39;accumulator=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulator</span><span class="p">]</span>
        <span class="n">arg_str</span> <span class="o">=</span> <span class="s">&#39;,</span><span class="se">\n</span><span class="s">   &#39;</span> <span class="o">+</span> <span class="s">&#39;,</span><span class="se">\n</span><span class="s">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">arg_list</span> <span class="k">if</span> <span class="n">el</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&#39;applying(</span><span class="se">\n</span><span class="s">   specifier=</span><span class="si">%s%s</span><span class="se">\n</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specifier</span><span class="o">.</span><span class="n">_pprint</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">arg_str</span><span class="p">)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/topo-banner7.png" alt="Logo"/>
            </a></p>
<ul class="global-toc">
<li><a href="../../index.html">Home</a></li>
<li><a href="../../News/index.html">News</a></li>
<li><a href="../../Downloads/index.html">Downloads</a></li>
<li><a href="../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../User_Manual/index.html">User Manual</a></li>
<li><a href="../../Reference_Manual/index.html">Reference Manual</a></li>
<li><a href="../../Developer_Manual/index.html">Developer Manual</a></li>
<li><a href="../../Forums/index.html">Forums</a></li>
<li><a href="../../Team_Members/index.html">Team Members</a></li>
<li><a href="../../Future_Work/index.html">Future Work</a></li>
<li><a href="../../FAQ/index.html">FAQ</a></li>
<li><a href="../../Links/index.html">Links</a></li>
<li><a href="../../Home/pubs.html">Publications</a></li>
</ul>
<h3><a href="../../index.html">Table Of Contents</a></h3>


<h3>This Page</h3>
<ul class="this-page-menu">
	<li><a	href="https://github.com/ioam/topographica/edit/master/doc/_modules/lancet/core.rst" rel="nofollow">Edit on GitHub</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../Downloads/index.html">Downloads</a></li>
<li><a href="../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../User_Manual/index.html">User Manual</a></li>


<li><ul class="parents">



          <li><a href="../index.html" >Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, IOAM.
      Last updated on Sep 11, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>